<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/javascript">
    if (location.href.endsWith("index.html")) {
      location.href = location.href.substring(0, location.href.length - "index.html".length);
    }
  </script>
  
    <title>
      算术基础（二）初等计数
    </title>
    

        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/default.min.css"
          media="(prefers-color-scheme: light)">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/dracula.min.css"
          media="(prefers-color-scheme: dark)">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/default.min.css"
          media="(prefers-color-scheme: no-preference)">
        <style type="text/css">
          body {
            width: 60%;
            margin: 0 auto;
            padding: 2em;
            font-family: 'Segoe UI',
              "Microsoft Yahei Light",
              "San Francisco",
              "Ping Fang SC",
              "Roboto",
              "Noto Sans CJK",
              Tahoma, Geneva, Verdana, sans-serif;
          }

          p>img {
            margin: 0 auto;
            display: block;
            max-width: 80%;
          }

          span.field {
            display: inline-block;
            font-weight: bolder;
            font-size: smaller;
          }

          pre {
            max-width: 90%;
            overflow-x: scroll;
            padding: 1em;
            border-radius: 5px;
          }

          a {
            text-decoration: none;
            color: cornflowerblue;
          }

          a:visited {
            color: cornflowerblue;
          }

          a:hover {
            color: darkgray;
          }

          a.disabled-link {
            color: lightcoral;
            text-decoration: line-through;
          }

          nav,
          nav ul {
            display: inline-block;
          }

          .tags ul,
          footer ul {
            padding: 0;
            display: inline;
          }

          header h1 {
            display: inline-block;
            min-width: 320px;
            max-width: 50%;
            width: 50%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin: auto;
          }

          @media screen and (max-width: 1200px) {
            body {
              width: 90%;
              max-width: 720px;
              padding: 0;
              margin: 1em auto;
            }

            header h1 {
              max-width: 90%;
              width: 90%;
            }
          }

          nav li,
          .tags li,
          footer li {
            display: inline;
            border-right: 1px solid darkgray;
            padding: 0 1em;
          }

          nav li:last-child,
          .tags li:last-child,
          footer li:last-child {
            border: none;
          }

          .post-list h3 {
            margin: 0.3em 0;
          }

          blockquote {
            margin: 0.5em;
            border: 1px dotted darkgrey;
            border-radius: 0.5em;
            padding: 0 1em;
          }

          div.image-description {
            text-align: center;
            color: gray;
            font-size: smaller;
          }

          @media (prefers-color-scheme: dark) {
            body {
              background-color: #090810;
              color: floralwhite;
              opacity: 0.83;
            }

            pre {
              background-color: #282a36;
            }
          }
        </style>
        <script>
          var _hmt = _hmt || [];
          (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?d06710df49879016f95c45042560225e";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
          })();
          </script>
</head>

<body>

  <header>
    
      <h1 title="算术基础（二）初等计数">
        算术基础（二）初等计数
      </h1>
      
          <nav>
            <ul>
              <li><a href="/">Home</a></li>
              <li><a href="/articles">Articles</a></li>
              <li><a href="/about">About</a></li>
            </ul>
          </nav>
          <hr>
          <span class="field">Author: <a href="/about">KimmyLeo</a></span>
          
  </header>
  <article>
    <p>当你能够区分开数和量的时候，我们就开始学习计数（counting）。</p>
<p>所谓计数，即是指用数来描述量，有时还会伴随这个描述的过程。当然，一切基本的计数过程，都要先从零开始。</p>
<p>以为一切事情本来就是从无到有的过程，“无”，就是那个初始状态，各种数制的表示都是0，程序员称为null或者nil，英语中叫empty或者nothing，爱打玄机的人称之为道。然后，“无中生有”，有了唯一的一个事物产生了，数字的描述为1；再然后，“道生一，一生二，二生三，三生万物”。到“二”的时候，数字的表示就开始有不同，二进制是逢二进一，所以“二”表示出来的结果是10，而在其他三个数制中仍然是2。所以跟一个程序员玩数数游戏的时候，千万不要用100这样的数字，请明确说明是一百（这个量跟二进制中的100有着很大的差距），或者干脆直接数到3。</p>
<p>这样一直逢进，四个进制之间的表示形式会越来越不同，但是总有一个是不变的，就是他们所表示的是同一个数量。于是，当我们需要对一个系统定量的时候，就可以使用计数来表示。</p>
<p>但是，问题来了。如果我们要把两个数量合并起来（比如，把这一讲的文字的数量和上一讲合在一起统计），合成以后就会有一个新的数量产生，这时候要确定这个量的数字表示，则还要重新进行一次计数。如果简单点的还可以，但是对于文字这种动辄数量庞大的东西，进行一次计数还是很费力的，而且这一系列的内容还不只是一两篇那么简单，一遍遍的重复计数是一个很伤人的事情。</p>
<p>估计我们伟大的先人们意识到了这一点，于是把“合并两个数量”这个内容进行了深度的研究，得到了一个通用的方法——加法（addition）。于是算术就不只是计数这么简单了，而开始有了质的飞跃。想对量进行合并统计就只要通过加法运算一步就可以得出结果了，没必要再对两个量的合集重新进行一次计数这么复杂低效的活动了；更进一步的，加法还能够简化计数，如果你需要通过计数来对一个系统定量，则先把这个系统中的量分成几部分，分别对这几部分进行计数，最后只需要把这几部分的计数相加求和，就能够得原系统量化的结果了，由于几个部分互不相干，所以计数可以同时进行，这样子就能够缩短整体的计数时间（你看到分治法（divide and conquer）和并行（parallel）思想了么？）。</p>
<p>但这些人没有意识到，这虽然是算术发展的很基础的一小步，却意味着整个人类历史进程发展的一大步：由简单的加法逐渐导出基本算术运算，最后一步步发展成为现在时刻影响着世界的数学（mathematics）。很明显，没有数学，就基本上没有我们现在的一切。</p>
<p>加法基本上可以看成是最简单的一个抽象出来的数学方法，虽然现在理解起来没什么难度。可是，简单的抽象还是难搞定越发复杂的问题，问题搞定得很困难的时候就会暴露出来等待有效的解决方案了。</p>
<p>这个问题还是跟计数有关。类似那个用分治法来解决的问题，需要统计一部如同红楼梦般的有一百多回目的书中文字的数量，于是分派一百多个人，每人负责对一个回目计数，最后所要得出的量就是一百多个人的计数结果相加，这样就要加一百多次，相对来说也是一个比较浪费时间的工作。当然，现在来看并非所有对较多的数量求和的情况都是浪费时间的，如果这些数的分布是符合某种规律的，则可以用一两个公式就能搞定，但是要知道，我们目前只有计数和加法这两种运算，只能根据这两者设计方案。</p>
<p>我这里给出两种解决方案，方案二对数据有一定的要求。</p>
<ul>
<li>方案一：仍然用计数时的分治思想，既然我有一百多个数据，加法求和反复做起来很恼火，那么我可以把这些数据分成几部分，对每部分数据先求和，然后再把这几部分的数据统一起来进行求和；这样子能够立马减少求和的步骤数，而如果再反复利用这种方法，就可以很大程度上减少步骤，节省时间。</li>
<li>方案二：既然能够从计数中抽象出加法运算来，那么从加法中抽象出另外一种运算似乎也是可行的；如果所有人完成第一步的计数工作，发现每个数量都相同，当这一数量每一次被加上去时都能感觉到一些略微的规律，再一次、再多次的研究表明这个规律是普遍性的，于是就能够产生另外一种运算——乘法（multiplication），来简化相同的量多次合并的问题了。</li>
</ul>
<p>虽然方案二的说法会有各种不同各种牵强，甚至根本就不能算是一个方案。可是它给出了一个新的方法，从而将多步重复的运算简化到一步，对于大量数据的统计，效率也能够提高出不少。</p>
<p>我们从其他的角度来对比一下这两个方案。</p>
<p>方案一使用的是分治法，一个只存在理论上的思想方法，而针对具体问题则要选择具体的如何“分”如何“治”：如方案一中的分治和用加法简化计数的分治就有这明显的不同。而类似分治法其更倾向于是用于产生具体方法的方法学工具，而非具体的方法，这种抽象层次要高出不少。</p>
<p>方案二则是针对重复的过程而抽象出来的一个具体运算方法（乘法），而于是乘法就作为一个固定的工具可以参与自然数的运算了。同样的，在这个方案中的对重复内容的抽象则是其背后的思想支撑。而这一思想同样也无处不在。</p>

      

  </article>
  <!-- <div>
        <h5>See Also</h5>
        <ul>
            <li><a href="/about">About Me</a></li>
        </ul>
    </div> -->
  <span class="field">创建时间：2013-07-03</span>
  <span class="field">最近更新时间：2021-04-13</span>
  <hr>
  <footer>
    <ul>
      <li><a href="/about">关于我</a></li>
      <li><a href="/sitemap.xml">站点地图</a></li>
      <li><a href="/rss.xml">RSS</a></li>
      <li>Copyright &copy; KimmyLeo</li>
    </ul>
  </footer>
  <script type="text/javascript">
    document.querySelectorAll(".disabled-link").forEach(el => el.addEventListener("click", (e) => {
      alert("链接页面不存在！");
      e.preventDefault();
    }));
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script
</body>

</html>
