<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>21天精通C++模板语言</title>
    
    <style type="text/css">
        body {
            width: 60%;
            margin: 0 auto;
            padding: 2em;
            font-family: 'Segoe UI',
                "Microsoft Yahei Light",
                "San Francisco",
                "Ping Fang SC",
                "Roboto",
                "Noto Sans CJK",
                Tahoma, Geneva, Verdana, sans-serif;
        }

        a {
            text-decoration: none;
            color: cornflowerblue;
        }

        a:visited {
            color: cornflowerblue;
        }

        a:hover {
            color: darkgray;
        }

        a.disabled-link {
            color: lightcoral;
            text-decoration: line-through;
        }

        nav,
        nav ul {
            display: inline-block;
        }

        .tags ul,
        footer ul {
            padding: 0;
            display: inline;
        }

        header h1 {
            display: inline-block;
            min-width: 320px;
            max-width: 50%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin: auto;
        }

        @media screen and (max-width: 1200px) {
            body {
                width: 90%;
                max-width: 720px;
            }
            header h1 {
                max-width: 100%;
            }
        }

        nav li,
        .tags li,
        footer li {
            display: inline;
            border-right: 1px solid black;
            padding: 0 1em;
        }

        nav li:last-child,
        .tags li:last-child,
        footer li:last-child {
            border: none;
        }

        .post-list h3 {
            margin: 0.3em 0;
        }
    </style>
</head>

<body>

    <header>
        
        <h1 title="21天精通C++模板语言">21天精通C++模板语言</h1>
        
        <nav>
            <ul>
                <li><a href="/">Home</a></li>
                <li><a href="/articles">Articles</a></li>
                <li><a href="/about">About</a></li>
            </ul>
        </nav>
        <hr>
        <span>Author: <a href="/about">KimmyLeo</a></span>
        <span>2014-12-31</span>
        
    </header>
    <article>
        <p>这篇文章最初发布于我的Lofter博客：</p>
<ul>
<li><a href="http://kimleo.lofter.com/post/46977_4f86f38" title="undefined">http://kimleo.lofter.com/post/46977_4f86f38</a></li>
<li><a href="http://kimleo.lofter.com/post/46977_509271f" title="undefined">http://kimleo.lofter.com/post/46977_509271f</a></li>
</ul>
<p>这是看憋了很久没有完成的21天学成Erlang之后才萌生的一个想法。所有的代码源自于我的一个项目Canvas/tpl。</p>
<p>另外：</p>
<blockquote>
<p><strong>Warning</strong>：文中提到的所有技术都未经生产实践检验。如果大家希望通过学习C++模版元编程进而提升一些生产实践的效率，可以转到吴野菊苣的GitHub去学习，或者是去知乎/微博 @vczh。</p>
</blockquote>
<p>好吧，废话到这里结束，我们进入正题：</p>
<p>为什么是C++模版？</p>
<ul>
<li>C++模版给我们提供了一套自由的类型系统</li>
<li>C++模版是原生支持模式匹配和递归的</li>
<li>C++模版可以允许我们对其进行动态扩展</li>
<li>最重要的是，我们能够并且必须用C++模版重新构造整个世界。包括从如何数（shǔ）数（shù）开始。因为模版是图灵完备的。</li>
</ul>
<p>OK，接下来是我们的整套计划：</p>
<ul>
<li>构造</li>
<li>使用</li>
<li>相等性与同一</li>
<li>模式匹配</li>
<li>类型限定</li>
<li>递归</li>
<li>扩展</li>
<li>表</li>
<li>映射与规约</li>
<li>数据结构</li>
<li>抽象（Range）</li>
<li>对象与状态</li>
<li>函数式思维</li>
<li>表达式树</li>
<li>求值</li>
<li>解释器</li>
</ul>
<p>嗯，没错，我们也是走的同样的一条路：用C++模版最后写出一个类Scheme语言的解释器。</p>
<p>好的我们开始吧。</p>
<p>首先是构造整个世界，要从如何数数开始。</p>
<pre><code class="language-c++">struct zero{};

template&lt;class Nat&gt;
struct succ{};</code></pre>
<p>很简单嘛，我们就把整个自然数系统给构建出来了。</p>
<p>为什么要这么说？因为皮埃诺公理说明我们是正确的。</p>
<p>于是<code>zero</code>表示自然数0，<code>succ&lt;zero&gt;</code>就可以表示自然数1，<code>succ&lt;n&gt;</code>就可以表示自然数n+1。</p>
<p>当然，也许我们需要知道更多的关于自然数的信息，比如它的前驱是什么？</p>
<p>这里的定义是，如果<code>succ&lt;x&gt; = n</code>，那么，<code>x = pred&lt;n&gt;</code>。</p>
<p>但是目前如何表示这个关系呢？</p>
<p>我们试着把<code>succ</code>修改一下：</p>
<pre><code class="language-c++">template&lt;class Nat&gt;
struct succ{ using pred = Nat; };</code></pre>
<p>很简单了，succ<n>::pred = n。</p>
<p>任何时候都能够这样使用我们在代码中定义的这些结构，比如作为形式参数（如Nat），作为实际参数（succ<n>中的n），作为属性值（succ<n>::pred中的pred）。</p>
<p>话说，怎么知道succ<n>::pred = n就一定是正确的呢？</p>
<p>在这之前，我们还要定义相等性：</p>
<pre><code class="language-c++">struct $true{};

struct $false{};

template&lt;class Obj1, class Obj2&gt;
struct equal{ using value = $false; };

template&lt;class T&gt;
struct equal&lt;T,T&gt;{ using value = $true; };</code></pre>
<p>没错，这就是相等性的玩法。当然这也是一个小技巧，当<code>equal</code>遇到他的两个参数都是同一个的时候，属性<code>value</code>就是<code>$true</code>。至于<code>$true</code>和<code>$false</code>代表的是什么，就看我们自己的约定啦。</p>
<p>然后是弄一个辅助测试的结构，来帮助我们进行每一次过程中的测试：</p>
<pre><code class="language-c++">template&lt;class Result&gt;
struct Assert{
    Assert() {throw 0;}
};

template&lt;&gt;
struct Assert&lt;$true&gt;{
    Assert() {}
};</code></pre>
<p>然后我们只需要在测试代码中这样写就好了：</p>
<pre><code class="language-c++">Assert&lt;typename equal&lt;typename succ&lt;zero&gt;::pred,
                zero&gt;::value&gt;();</code></pre>
<p>意图很明显，当我们测试用例的结果不为<code>$true</code>的时候，直接throw一个exception出来中止测试就好。</p>
<p>可以看出我们在定义<code>equal</code>和<code>Assert</code>的时候分别定义了多次，这其实是C++模版的一个很重要的东西，叫做模版（偏）特化。因为这个特性的存在，我们就可以让编译器按照我们设定好的参数模式去匹配相应的定义。嗯，没错这就是模式匹配。</p>
<p>比如，pred也可以这样子定义：</p>
<pre><code class="language-c++">struct undefined {};

template&lt;class T&gt;
struct pred{ using value=undefined; };

template&lt;class T&gt;
struct pred&lt;succ&lt;T&gt;&gt; 
{ using value=T; };</code></pre>
<p>完全按照pred的定义来。并且如果可以的话我们还能够继续加上一条：</p>
<pre><code class="language-c++">template&lt;&gt;
struct pred&lt;zero&gt; { using value=zero; };</code></pre>
<p>0的前驱也默认为0，防止后面出现某些错误情况。</p>
<p>但是到这里是否大家也发现了一个问题：</p>
<p>我们既可以使用<code>succ&lt;zero&gt;</code>，也可以使用<code>succ&lt;$false&gt;</code>，甚至是<code>succ&lt;undefined&gt;</code>，也就是说，模版带给我们方便的类型系统的同时，并没有很细致的告诉我们，哪些操作是错误的。而同时我们又需要避免这个错误。</p>
<p>但还好可以写出以下这种样子的代码：</p>
<pre><code class="language-c++">template&lt;class Nat&gt;
struct succ;

template&lt;&gt;
struct succ&lt;zero&gt; {};

template&lt;class Nat&gt;
truct succ&lt;succ&lt;Nat&gt;&gt; {};</code></pre>
<p>当我们去<code>succ</code>除了<code>zero</code>和<code>succ&lt;...&gt;</code>之外的任何结构的时候，都会造成一次失败的展开。</p>
<p>好的，有了这些东西我们就可以自在地数数了。但是可能用来表示一个大数还是很困难，比如6就要这样子表示：</p>
<pre><code class="language-c++">succ&lt;succ&lt;succ&lt;succ&lt;succ&lt;succ&lt;zero&gt;&gt;&gt;&gt;&gt;&gt;</code></pre>
<p>当然这么做的话就太失败了。其实我们只要把加法和乘法定义出来，就能够做到简单的来表示一些比较大的数字了。</p>
<pre><code class="language-c++">template&lt;class Num1, class Num2&gt;
struct add;

template&lt;class Num1&gt;
struct add&lt;zero, Num1&gt;
{ using value = Num1; };

template&lt;class Num1, class Num2&gt;
struct add&lt;succ&lt;Num1&gt;, Num2&gt;
{ using value = typename add&lt;Num1, succ&lt;Num2&gt;&gt;::value; };</code></pre>
<p>对应到Haskell-like的代码如下：</p>
<pre><code class="language-haskell">add :: nat -&gt; nat -&gt; nat
add 0 n = n
add (succ m) n = add m (succ n) </code></pre>
<p>递归就是这么简单;)。</p>
<p>然后我们看乘法：</p>
<pre><code class="language-c++">template&lt;class Num1, class Num2&gt;
struct mul;

template&lt;class Num1&gt;
struct mul&lt;zero, Num1&gt;
{ using value = zero; };

template&lt;class Num1, class Num2&gt;
struct mul&lt;succ&lt;Num1&gt;, Num2&gt;
{ using value = typename add&lt;Num2, 
                        typename mul&lt;Num1, 
                                Num2&gt;::value&gt;::value; };</code></pre>
<p>只是一个更复杂的递归。</p>
<blockquote>
<p>练习：试用递归定义出来幂运算。</p>
</blockquote>
<p>于是，我们就能用现有的运算来定义更复杂的内容了：</p>
<pre><code class="language-c++">using i0 = zero;
using i1 = succ&lt;zero&gt;;
using i2 = succ&lt;i1&gt;;
using i3 = succ&lt;i2&gt;;
using i4 = typename add&lt;i2, i2&gt;::value;
// blablabla</code></pre>
<p>然后我们可以定义一个更加容易的定义数据的方式：</p>
<pre><code class="language-c++">template&lt;class Num, class... Nums&gt;
struct decimal
{ using value = typename add&lt;typename mul&lt;i10, Num&gt;::value,
                            typename decimal&lt;Nums...&gt;::value&gt;::value; };

template&lt;class Num&gt;
struct decimal&lt;Num&gt;
{ using value = Num; };</code></pre>
<blockquote>
<p>练习：请根据以下声明来定义用于布尔类型的操作。
（Hint：模式匹配）</p>
<pre><code class="language-c++">template&lt;class Bool1, class Bool2&gt;
struct $and;

template&lt;class Bool1, class Bool2&gt;
struct $or;

template&lt;class Bool, class Op1, class Op2&gt;
struct $if;</code></pre>
</blockquote>
<p>接下来我们看另外一个重要的结构，列表。</p>
<pre><code class="language-c++">struct nil { using length = zero; };

template&lt;class First, class Rest&gt;
struct pair
{ using length = succ&lt;typename Rest::length&gt;; };</code></pre>
<p>对应来一个创建列表的构造：</p>
<pre><code class="language-c++">template&lt;class Head, class... Tail&gt;
struct list {
    using value = pair&lt;Head, typename list&lt;Tail...&gt;::value&gt;;
    using length = typename value::length;
};

template&lt;class Head&gt;
struct list&lt;Head&gt; {
    using value = pair&lt;Head, nil&gt;;
    using length = i1;
};</code></pre>
<blockquote>
<p>如<code>list&lt;Elems...&gt;</code>构造的样子，列表本身就是一个递归的结构，所以，对于大多数列表的处理，我们都可以通过使用递归来实现。</p>
</blockquote>
<p>比如：</p>
<pre><code class="language-c++">template&lt;class Num, class List&gt;
struct take;

template&lt;class Head, class Tail, class Num&gt;
struct take&lt;succ&lt;Num&gt;, pair&lt;Head, Tail&gt;&gt;
{ using value = pair&lt;Head, typename take&lt;Tail, Num&gt;::value&gt;; };

template&lt;class Num&gt;
struct take&lt;Num, nil&gt; { using value = nil; };

template&lt;class List&gt;
struct take&lt;zero, List&gt; { using value = nil; };</code></pre>
<p>同理：</p>
<blockquote>
<p>练习：实现<code>drop :: nat -&gt; [x] -&gt; [x]</code>和<code>concat :: [x] -&gt; [x] -&gt; [x]</code>函数；前者用于返回去掉指定个数元素的列表，后者用于连接两个列表。</p>
</blockquote>
<p>于是，我们有了对列表的一些基本构造法。同样的利用这些构造法，我们就能够做更多地操作。比如，<code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>：</p>
<pre><code class="language-c++">template&lt;template&lt;class A&gt; class Fn, class ListA&gt;
struct map;</code></pre>
<p>map接受一个从A到B的变换，然后接受一个A类型元素的列表，把该变换对应到列表的每一个元素，然后产生一个新的B类型元素的列表。</p>
<pre><code class="language-c++">template&lt;template&lt;class A&gt; class Fn, class Head, class Tail&gt;
struct map&lt;Fn, pair&lt;Head, Tail&gt;&gt;{
    using value = pair&lt;typename Fn&lt;Head&gt;::value,
                            typename map&lt;Fn, Tail&gt;::value&gt;;
};

template&lt;template&lt;class A&gt; class Fn&gt;
struct map&lt;Fn, nil&gt;{
    using value = nil;
};</code></pre>
<blockquote>
<p>练习：实现<code>filter :: (a -&gt; bool) -&gt; [a] -&gt; [a]</code>。</p>
</blockquote>
<p>其实，作为组合数据结构来说，还有更多的类型。</p>
<p>比如</p>
<pre><code class="language-c++">template&lt;class... Elems&gt;
struct array {};</code></pre>
<p>我们定义一个新的函数叫做<code>index :: num -&gt; array of a -&gt; a</code>：</p>
<pre><code class="language-c++">template&lt;class Num, class Array&gt;
struct index;

template&lt;class Num, class Elem, class... Elems&gt;
struct index&lt;succ&lt;Num&gt;, array&lt;Elem, Elems...&gt;&gt;{
    using value = typename index&lt;Num, array&lt;Elems...&gt;&gt;::value;
};

template&lt;class Elem, class... Elems&gt;
struct index&lt;zero, array&lt;Elem, Elems...&gt;&gt; {
    using value = Elem;
};</code></pre>
<p>因为跟<code>list</code>有着类似的形式：表示形式上的线性和处理形式上的递归性，所以我们似乎可以考虑把对于<code>list</code>的某些操作转换到<code>array</code>上，比如：</p>
<pre><code class="language-c++">template&lt;template&lt;class A&gt; class Fn, class... Elems&gt;
struct map&lt;Fn, array&lt;Elems...&gt;&gt; {
    using value = array&lt;typename Fn&lt;Elems&gt;::value...&gt;;
};</code></pre>
<p>毫无违和感。C++模版给我们提供的parameter pack成功的帮我们简化了操作。同样，依赖着partial specialization技术，这样子对map进行扩展也没有什么异样。</p>
<blockquote>
<p>练习：尝试写一个<code>range</code>构造，用法与Python的<code>range</code>函数类似，同样的，写出一个与该构造对应的<code>map</code>函数</p>
</blockquote>
<p>模版给了我们自由创造构造和添加扩展的能力，一方面用于组合数据，另一方面用于提供抽象操作。而根据我之前的论证，这两点足以让我们组合出更复杂的程序。</p>
<p>所以接下来我们就来写一个简单的逻辑求值器。</p>
<p>首先是各项的表示：（Hint：为了避免名字冲突问题，请尽量把前面表示布尔和逻辑关系的一些项与本节内容放在不同空间内（本节假设为boolean）。</p>
<pre><code class="language-c++">struct $false {};

template&lt;class T&gt;
struct $var {};

using $undefined = $var&lt;$false&gt;;

template &lt;class Prop1, class Prop2&gt;
struct $and {};

template&lt;class T&gt;
struct $not {};

using $true = $not&lt;$false&gt;;

template&lt;class Var, class Prop&gt;
struct $exists {};

template &lt;class Prop1, class Prop2&gt;
using $or = $not&lt;$and&lt;$not&lt;Prop1&gt;, $not&lt;Prop2&gt;&gt;&gt;;

template &lt;class Prop1, class Prop2&gt;
using $iff = $or&lt;$and&lt;Prop1, Prop2&gt;, $and&lt;$not&lt;Prop1&gt;, $not&lt;Prop2&gt;&gt;&gt;;

template &lt;class Prop1, class Prop2&gt;
using $implies = $or&lt;$not&lt;Prop1&gt;, Prop2&gt;;

template &lt;class Var, class Prop&gt;
using $forall = $not&lt;$exists&lt;Var, $not&lt;Prop&gt;&gt;&gt;;</code></pre>
<p>有了这些，我们就有了一套清晰的结构来表达任意复杂的命题逻辑了。</p>
<p>比如：</p>
<pre><code class="language-c++">$exists&lt;$var&lt;A&gt;, $forall&lt;$var&lt;B&gt;, $implies&lt;B, A&gt;&gt;&gt;</code></pre>
<p>每个表达式，要么是一个基本构造（比如<code>$false</code>， <code>$not</code>），要么是能通过一个等价变换转换成基本构造（比如<code>$forall</code>、<code>$implies</code>）。所以这样子就能让这些表达式反复组合，从简单到变到复杂；而同样的一个任意复杂的表达式也可以一层一层的展开成最简单的基本构造。展开后的结果大致上是一个树形，一般称为AST。</p>
<p>于是对一个命题逻辑表达式求值为的过程就是对其进行一步步的展开然后再一步步的归约成最终结果的过程。</p>
<p>于是我们可以把这个求值器抽象成这个样子：</p>
<pre><code class="language-c++">template&lt;class Env, class Prop&gt;
struct eval;</code></pre>
<p>在指定环境中对指定表达式进行求值。</p>
<p>比如：</p>
<pre><code class="language-c++">template&lt;class Env&gt;
struct eval&lt;Env, $false&gt; {
    using value = boolean::$false;
};

template&lt;class Env, class Prop&gt;
struct eval&lt;Env, $not&lt;Prop&gt;&gt;{
    using value = typename boolean::$not&lt;
                                            typename eval&lt;Env, Prop&gt;::value
                                        &gt;::value
};

template&lt;class Env, class Prop1, class Prop2&gt;
struct eval&lt;Env, $and&lt;Prop1, Prop2&gt;&gt;{
    using value = typename boolean::$and&lt;
                                            typename eval&lt;Env, Prop1&gt;::value,
                                            typename eval&lt;Env, Prop2&gt;::value
                                        &gt;::value;
};</code></pre>
<p>当然这里处理起来很简单，我们只需要按照表达式的结构对其递归求值即可。不过当引入量化（exists、forall）和变量的时候，就需要考虑一下深层的问题了。</p>
<p>首先要考虑的是如何构建和查询求值环境：</p>
<pre><code class="language-c++">template&lt;class A, class B&gt;
struct $entry {
    using first = A;
    using next = B;
};

template&lt;class Var = $undefined, 
                    class Val = $false, 
                    class List = list::nil&gt;
struct $env {
    using value = typename list::pair&lt;$entry&lt;Var,Val&gt;, List&gt;;
};

template&lt;class Env,class Val&gt;
struct $env_lookup {
    template&lt;class Var&gt;
    struct helper {
        using value = typename boolean::same&lt;Val, typename Var::first&gt;::value;
    };
    using value = typename list::iter::find&lt;helper, typename Env::value&gt;::value::next;
};</code></pre>
<p>解释起来很简单，env其实就是用list来实现的，然后我们利用<code>list::iter::find</code>（ <code>(a -&gt; bool) -&gt; [a] -&gt; a</code>，返回列表中第一个符合条件的元素）实现了查找env中的变量的值。</p>
<p>嗯，有了这两样东西，我们就可以完整的实现eval了：</p>
<pre><code class="language-c++">template&lt;class Env, class Var&gt;
struct eval&lt;Env, $var&lt;Var&gt;&gt; {
    using value = typename $eval&lt;Env, 
                            typename $env_lookup&lt;Env, $var&lt;Var&gt;&gt;::value 
                        &gt;::value;
};

template &lt;class Env, class Var, class Prop&gt;
struct eval&lt;Env, $exists&lt;Var, Prop&gt;&gt; {
    using value = typename boolean::$or&lt;
                    typename $eval&lt;$env&lt;Var,
                                            $false,
                                            typename Env::value&gt;,
                                        Prop&gt;::value,
                    typename $eval&lt;$env&lt;Var,
                                            $true,
                                            typename Env::value&gt;,
                                        Prop&gt;::value
                    &gt;::value;
};</code></pre>
<p>嗯，没错就这么简单。</p>
<p>看一下测试代码吧：</p>
<pre><code class="language-c++">AssertAll&lt;
    typename $eval&lt;$env&lt;&gt;, $true&gt;::value, /// T
    typename $eval&lt;$env&lt;&gt;, $not&lt;$false&gt;&gt;::value,    /// !F
    typename $eval&lt;$env&lt;&gt;, $or&lt;$false,$true&gt;&gt;::value,  /// F || T
    typename $eval&lt;$env&lt;&gt;, $implies&lt;$false,$true&gt;&gt;::value, /// F =&gt; T
    typename $eval&lt;$env&lt;&gt;, $iff&lt;$false,$false&gt;&gt;::value,    /// F &lt;=&gt; F
    typename $eval&lt;$env&lt;$var&lt;A&gt;, $false&gt;, $not&lt;$var&lt;A&gt;&gt;&gt;::value, /// A = F, !A

    /// A = T, !A =&gt; A
    typename $eval&lt;$env&lt;$var&lt;A&gt;, $true&gt;,  $implies&lt;$not&lt;$var&lt;A&gt;&gt;, $var&lt;A&gt;&gt;&gt;::value,

    /// forall A, T
    typename $eval&lt;$env&lt;&gt;, $forall&lt;$var&lt;A&gt;, $true&gt;&gt;::value,
    /// exists A, !A
    typename $eval&lt;$env&lt;&gt;, $exists&lt;$var&lt;A&gt;, $not&lt;$var&lt;A&gt;&gt;&gt;&gt;::value
&gt;();</code></pre>
<p>有了这么几个实例，我觉的写Scheme解释器应该不是问题了吧。</p>

        

    </article>
    <!-- <div>
        <h5>See Also</h5>
        <ul>
            <li><a href="/about">About Me</a></li>
        </ul>
    </div> -->
    <hr>
    <footer>
        <ul>
            <li><a href="/about">关于我</a></li>
            <li><a href="/sitemap.xml">站点地图</a></li>
            <li><a href="/rss.xml">RSS</a></li>
            <li>Copyright &copy; KimmyLeo</li>
        </ul>
    </footer>
    <script type="text/javascript">
        document.querySelectorAll(".disabled-link").forEach(el => el.addEventListener("click", (e) => {
            alert("链接页面不存在！");
            e.preventDefault();
        }))
    </script>
</body>

</html>